struct Entry{
    int element;
    Entry next;
    Entry previous;
}

Entry newEntry(){
    Entry n = new Entry();
    n.previous = null;
    n.next = null;
    return n;
}

struct LinkedList{
    Entry header;
    int size;
}

LinkedList newList() {
    LinkedList l = new LinkedList();
    l.header = newEntry();
    l.size = 0;
    return l;
}

void addFirst(LinkedList l, int o) {
    Entry t = l.header.next;
    Entry e = newEntry();
    e.element = o;
    l.header.next = e;
    e.previous = l.header;
    e.next = t;
    update_Entry(t,e,l); //BUG Entry
    update_Size(l); //BUG size
}

//should be auto
void update_Entry(Entry t, Entry e, LinkedList l) {
    //find all direct field with same type
    Entry head = l.header;
    if (condition_Entry(t,e,head))
        t.previous = {|(e|head|t) (.next|.previous)?|}; 
}

//should be auto
bit condition_Entry(Entry t, Entry e, Entry head) {
    Entry a = {|(t|e|head)(.next|.previous)?|};
    Entry b  = {|t|e|head|null|};
    return {|a==b|a!=b|true|};
}
//should be auto
void update_Size(LinkedList l) {
    if (condition_size(l.size,l.header.element))
        l.size = {|l.size|l.header.element|}+??;
}
//should be auto
bit condition_size(int p, int q) {
   int a = {|p|q|};
    int b  = ??;
    return {|a==b|a!=b|true|};
}

void checkList(LinkedList l) {
        Entry head = l.header;
        assert head.previous == null;
        Entry cur = head.next;
        Entry prev = head;
        int len = 0;
        while (cur != null) {
            assert cur.previous == prev;
            assert prev.next == cur;
            prev = cur;
            cur = cur.next;  
            len = len+1;
        }
        assert prev.next == null;
        assert len == l.size;
    }

harness void insertFrontHarness() {
    int length = 5;
    LinkedList l = newList();
    Entry cur = l.header;
    //test insert
    for (int i = 0; i < length; i++) {
        addFirst(l, i);
        checkList(l);
    }
//test insert correct;
  cur = l.header.next;
    for (int i = 0; i < length; i++) {
      assert cur.element == length - i - 1;
       cur = cur.next;
   }
  assert cur == null;   
}
