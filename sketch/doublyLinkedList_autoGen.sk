struct Entry{
    int element;
    Entry next;
    Entry previous;
}

Entry newEntry(){
    Entry n = new Entry();
    n.previous = null;
    n.next = null;
    return n;
}

struct LinkedList{
    Entry header;
    int size;
}

LinkedList newList() {
    LinkedList l = new LinkedList();
    l.header = newEntry();
    l.header.next = l.header;
    l.header.previous = l.header;
    l.size = 0;
    return l;
}

Entry addFirst(LinkedList l, int o) {
    Entry t = l.header.next;
    Entry e = newEntry();
    e.element = o;
    l.header.next = e;
 //  e.previous = l.header;//suspicious
   update1_entry(t,e,l); 
    e.next = t;
   update2_entry(t,e,l); 
    //t.previous =l.header;//BUG
    //omission: size
 //   update_size(l); //BUG size
    return e;
}

//should be auto
void update1_entry(Entry t, Entry e, LinkedList l) {
    //find all direct field with same type
    Entry head = l.header;
    Entry a = {|(t|e|head)(.next|.previous)?|};
    Entry b  = {|(t|e|head)(.next|.previous)?|null|};
    if ({|a==b|a!=b|true|false|})
        e.previous = {|(t|e|head)(.next|.previous)?|null|}; 
}

//should be auto
void update2_entry(Entry t, Entry e, LinkedList l) {
    //find all direct field with same type
    Entry head = l.header;
    Entry a = {|(t|e|head)(.next|.previous)?|};
    Entry b  = {|(t|e|head)(.next|.previous)?|null|};
     if ({|a==b|a!=b|true|false|})
        t.previous = {|(t|e|head)(.next|.previous)?|null|}; 
}

//should be auto
void update3_entry(Entry t, Entry e, LinkedList l) {
    Entry head = l.header;
    Entry a = {|(t|e|head)(.next|.previous)?|};
    Entry b  = {|(t|e|head)(.next|.previous)?|null|};
     if ({|a==b|a!=b|true|false|})
       {|(t|e|head)(.next|.previous)?|} = {|(t|e|head)(.next|.previous)?|null|}; 
}
//should be auto
void update_size(LinkedList l) {
    int a={|l.size|l.header.element|??|};
    int b = {|l.size|l.header.element|??|};
    if ({|a==b|a!=b|true|}) {
        l.size = {|l.size|l.header.element|}+??;
        }
}

harness void insertFrontHarness() {
    LinkedList l = newList();
    
    //insert 1
    Entry one = addFirst(l,1);
    assert l.header.next == one;
    assert one.next == l.header;
    assert one.previous == l.header;
   // assert l.size == 1;
    assert one.element == 1;
    
    //insert 2
    Entry two = addFirst(l,2);
    assert l.header.next == two;
    assert two.next == one;
    assert two.previous == l.header;
    assert one.next ==l.header;
    assert one.previous == two;
  //  assert l.size == 2;
    assert two.element ==2;
}
