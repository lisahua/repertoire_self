struct Entry{
    int element;
    Entry next;
    Entry previous;
}

Entry newEntry(){
    Entry n = new Entry();
    n.previous = null;
    n.next = null;
    return n;
}

struct LinkedList{
    Entry header;
    int size;
}

LinkedList newList() {
    LinkedList l = new LinkedList();
    l.header = newEntry();
    l.header.next = l.header;
    l.header.previous = l.header;
    l.size = 0;
    return l;
}

Entry addFirst(LinkedList l, int o) {
    Entry t = l.header.next;
    Entry e = newEntry();
    e.element = o;
    l.header.next = e;
    e.previous = l.header;
    e.next = t;
    if (t != l.header)
    t.previous = e;
    l.size = l.size+1;
    return e;
}

void swapHeadTail(LinkedList l) {
    Entry t = l.header;
    while (t.next !=l.header){
    t = t.next;
    }
    if (t.previous == l.header) return ;
    Entry h_next = l.header.next;
   
   if (h_next.next ==t) {
    l.header.next = t;
    t.next = h_next;
    t.previous = l.header;
    h_next.next = l.header;
    h_next.previous = t;
    return;
    }
    
    l.header.next = t;
    h_next.previous = t.previous;
    t.next = h_next.next;
    t.previous = l.header;
    h_next.next = l.header;
    
}

void swapTwoEntries(LinkedList l, Entry a, Entry b) {
    Entry t = l.header.next;
    if (a==null||b==null|| a==b) return ;
    if (l.header.next.next ==l.header) return;
    
    Entry d_a = null;
    Entry d_b =null;
    
    while (t!=l.header && d_a!=null && d_b !=null) {
    if (t.element ==a.element && t.previous == a.previous && t.next == a.next)
        d_a = t;
    if (t.element ==b.element && t.previous == b.previous && t.next == b.next)
        d_b  = t;
    }
    
    if (d_a==null|| d_b==null) return;
    
    if (d_a.next ==d_b|| d_b.next==d_a) {
        Entry t1 = null;
        Entry t2 = null;
        if (d_a.next==d_b){
            t1=d_a;
            t2=d_b;
        }
        if (d_b.next==d_a){
            t1=d_b;
            t2=d_a;
        }
        t1.next = t2.next;
        t2.previous = t1.previous;
        t1.previous.next = t2;
        t1.previous = t2.previous;
        t1.next.previous = t1;
        t2.next = t1;
        t1.previous = t2;
        return;
    }
    Entry p_a = a.previous;Entry p_b = b.previous;
    Entry n_a = a.next; Entry n_b = b.next;
    
    d_a.previous.next = d_b;
    d_b.next.previous = d_a;
    d_a.next.previous = d_b;
    d_b.previous.next = d_a;
    
    d_a.previous = p_b;
    d_a.next = n_b;
    d_b.previous = p_a;
    d_b.next = n_a;
}


harness void swapHeadTailHarness() {
     //Empty
     LinkedList l = newList();
     assert l.size ==0;
     assert l.header.next == l.header;
     assert l.header.previous == l.header;
     
     //insert 1
    Entry one= addFirst(l,1);
     assert l.header.next ==one;
    assert l.header.previous == l.header;
     assert one.next == l.header;
     assert one.previous == l.header;
    assert l.size ==1;
     
     //insert 2
     Entry two= addFirst(l,2);
     assert l.header.next ==two;
      assert l.header.previous == l.header;
     assert two.next == one;
     assert two.previous == l.header;
     assert one.next == l.header;
     assert one.previous == two;
        assert l.size ==2;
     
          //insert 3
     Entry three= addFirst(l,3);
     assert l.header.next ==three;
      assert l.header.previous == l.header;
     assert three.next == two;
     assert three.previous == l.header;
     assert two.next == one;
     assert two.previous == three;
     assert one.next == l.header;
     assert one.previous == two;
        assert l.size ==3;
}

harness void swapTwoEntriesHarness() {
     //Empty
     LinkedList l = newList();
     assert l.size ==0;
     assert l.header.next == l.header;
     assert l.header.previous == l.header;
     
     //insert 1
    Entry one= addLast(l,1);
     assert l.header.next ==one;
     assert one.next == l.header;
     assert one.previous == l.header;
        assert l.size ==1;
     
     //insert 2
     Entry two= addLast(l,2);
     assert l.header.next ==one;
     assert l.header.previous == l.header;
     assert one.next ==two;
     assert one.previous == l.header;
     assert two.next == l.header;
     assert two.previous == one;
        assert l.size ==2;
     
     //insert 3
     Entry three= addLast(l,3);
     assert l.header.next ==one;
     assert l.header.previous == l.header;
     assert one.next == two;
     assert one.previous == l.header;
     assert two.next == three;
     assert two.previous == one;
     assert three.next == l.header;
     assert three.previous == two;
        assert l.size ==3;
     
}
