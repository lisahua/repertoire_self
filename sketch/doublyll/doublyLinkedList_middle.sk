struct List{
    Node head;
    Node tail;
}

List newList() {
    List l = new List();
    l.head = null;
    l.tail = null;
    return l;
}
 
struct Node{
    int val;
    Node next;
    Node prev;
}
 
Node newNode(int v){
    Node n = new Node();
    n.val = v;
    n.prev = null;
    n.next = null;
    return n;
}

generator bit condition(List l, Node p) {
    Node a = {| l.head | l.tail |};
    Node b = {| null | p (.next | .prev)? |};    
    return {| a == b | a != b | true |};
}

generator void update(List l, Node n, Node p) {
    loop(??) {
        if (condition(l, p)) {
            {| (l.head | l.tail | (n | p) (.next | .prev)) (.next | .prev)? |} = {| l.head | l.tail | n | p (.next | .prev)? | null |}; 
        }
    }       
}

void insertFront(List l, Node n) {
    update(l, n, null);
}

void repOk(List l) {
    // head and tail should be either both null or both non-null
    if (l.head == null) {
        assert l.tail == null;                        
    } else {
        assert l.tail != null;
        Node n = l.head;
        // head node should have no predecessor
        assert n.prev == null;
        // tail node should have no successor
        assert l.tail.next == null;

        // check two consecutive nodes in the list for correct pointers
        Node cur = n.next;
        Node prev = n;
        while (cur != null) {
            assert cur.prev == prev;
            assert prev.next == cur;
            prev = cur;
            cur = cur.next;        
        }
        // last node should be tail
        assert prev == l.tail;
    }
}

harness void insertFrontHarness() {
    int length = 4;
    List l = newList();
    for (int i = 0; i < length; i++) {
        Node n = newNode(i);
        insertFront(l, n);
        repOk(l);
    }

    Node cur = l.head;
    for (int i = 0; i < length; i++) {
        assert cur.val == length - i - 1;
        cur = cur.next;
    }
    assert cur == null;   
}

void insertBack(List l, Node n) {
    update(l, n, null);
}

harness void insertBackHarness() {
    int length = 4;
    List l = newList();
    for (int i = 0; i < length; i++) {
        Node n = newNode(i);
        insertBack(l, n);
        repOk(l);
    }

    Node cur = l.head;
    for (int i = 0; i < length; i++) {
        assert cur.val == i;
        cur = cur.next;
    }
    assert cur == null;
}

void insertMiddle(List l, Node n, Node p) {
    update(l, n, p);
}

// a simple getter method for the list
Node nodeAt(List l, int idx) {
    Node curr = l.head;
    while (idx > 0) {
        curr = curr.next;
        idx -= 1;
    }
    assert curr != null;
    return curr;
}

// returns the size of a well formed list
int lstSize(List l) {
    Node curr = l.head;
    int result = 0;
    while (curr != null) {
        result++;
        curr = curr.next;
    }
    return result;
}

harness void insertMiddleHarness(int[5] insertOperations) {
    List l = new List();
    Node n0 = newNode(0);
    l.tail = n0;
    l.head = n0;
    
    for (int a = 0; a < 5; a++) {
        int eltIdx = insertOperations[a] % (a + 1);
        Node eltToInsertAfter = nodeAt(l, eltIdx);
        Node nodeToInsert = newNode(a + 1);
        insertMiddle(l, nodeToInsert, eltToInsertAfter);
        assert lstSize(l) == a + 2;
        assert eltToInsertAfter.next == nodeToInsert;
        assert nodeToInsert.prev == eltToInsertAfter;
        repOk(l);
    }
}


void remove(List l, Node p) {
    update(l, null, p);
}


harness void removeHarness(int[5] in, int idx, int length) {
    // assume 1 <= length <= 5
    if (length <= 5 && length >= 1) {       
       // create a list with l nodes
       List l = newList();
       
       for (int i = 0; i < length; i++) {           
           Node n = newNode(in[i]);
           if (l.head == null) {
               l.head = n;
               l.tail = n;
           } else {         
               l.tail.next = n;
               n.prev = l.tail;
               l.tail = n;
           }
       }
         
       // use j to indicate which node to remove
       int j = idx % length;
       Node p = nodeAt(l, j);

       // remove node      
       remove(l, p);
       repOk(l);

       // functional correctness
       assert lstSize(l) == length - 1;
       for (int i = 0; i < j; i++) assert nodeAt(l, i).val == in[i];
       for (int i = j; i < length - 1; i++) assert nodeAt(l, i).val == in[i+1];       
    }
}